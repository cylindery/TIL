# 그리디 알고리즘 (Greedy Algorithm)

그리디 알고리즘은 **현재 상황에서 가장 큰 이익**만을 좇는 방법.

그 순간마다 최적이라고 생각되는 것만을 선택하여 지역적으로는 최적이지만, 실제 전역적으로 최적이라는 보장은 없다.  
다만 그리디 알고리즘의 결과가 곧 전체 결과와 같아지는 경우가 더러 있는데,

1. 탐욕 선택 조건 (Greedy Choice Property)
2. 최적 부분 구조 조건 (Optimal Substructure)

이 두 가지 조건, 즉 **정당성**이 모두 만족되는 경우이다.  
탐욕 선택 조건이란 **앞의 선택이 이후의 선택에 영향을 주지 않는다**는 것이며, 최적 부분 구조 조건은 **문제에 대한 최적해가 부분 문제에 대해서도 역시 최적해**라는 것.

이러한 정당성이 성립되지 않을 경우, 그리디 알고리즘의 결과는 최적해가 아닌 최적해의 근사값에 머무른다.  
하지만 코딩 테스트의 그리디 알고리즘 문제는 **그리디 알고리즘으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론**할 수 있어야 풀리도록 출제됨.

## 문제 적용 팁

1. 문제를 풀기 위한 최소한의 아이디어를 떠올린다
2. 아이디어의 정당성을 분석한다
    1. 앞의 선택이 이후의 선택에 영향을 주지 않는가
    2. 문제의 최적해가 부분 문제에 대해서도 역시 최적해인가

## 예시

### 문제 <거스름돈>

당신은 음식점의 계산을 도와주는 점원입니다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정합니다. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하세요. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수입니다.

### 문제 해결 아이디어

최적의 해를 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러 주면 된다.  
500원, 100원, 50원, 10원 순서로 거슬러 줄 수 있을 만큼 거슬러 준다.

### 정당성 분석

왜 가장 큰 화폐 단위부터 돈을 거슬러 줄까?  
바로 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로, 작은 단위의 동전들을 아무리 조합해도 큰 단위의 조합보다 작은 개수를 사용할 수 없기 때문.

### 코드

```java
public class Main {
    public static void main(String[] args) {
        int n;
        int count = 0;
        int[] coinTypes = {500, 100, 50, 10};

        for (int i = 0; i < 4; i++) {
            count += n / coinTypes[i];
            n %= coinTypes[i];
        }

        System.out.println(count);
    }
}
```

## 출처

- [(이코테 2021 강의 몰아보기) 2. 그리디 & 구현 - YouTube](https://www.youtube.com/watch?v=2zjoKjt97vQ&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=2)
- [탐욕적 기법(Greedy Algorithm) .. : 네이버블로그](https://blog.naver.com/kks227/220775134486)
- [탐욕 알고리즘 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%ED%83%90%EC%9A%95_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
