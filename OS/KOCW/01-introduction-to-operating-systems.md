# 강의 소개

## 강의 목표 및 내용

### 강의 목표

운영체제는 컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어 계층으로서 모든 컴퓨터 시스템의 필수적인 부분이다.  
이 수업을 통해 **운영체제의 개념**과 **역할**, 운영체제를 **구성하는 각 요소** 및 그 **알고리즘**의 핵심적인 부분에 대해 기초부터 학습한다.

### 강의 내용

- 운영체제 개요
- 컴퓨터 시스템의 구조
- 프로세스 관리
- CPU 스케줄링
- 병행 제어
- 데드락
- 메모리 관리
- 가상 메모리
- 파일 시스템
- 입출력 시스템
- 디스크 관리

## 운영체제란 무엇인가?

### 운영체제(Operating System, OS)란?

컴퓨터 하드웨어 바로 위에 설치되어 **사용자** 및 다른 모든 **소프트웨어**와 **하드웨어**를 **연결**하는 **소프트웨어 계층**.  
사용자는 직접 하드웨어에 접근하지 않으면서 운영체제하고만 상호작용하며, 또한 다른 소프트웨어도 동일하다.

!그림

## 운영체제의 목표

### 1. 컴퓨터 시스템의 자원을 효율적으로 관리

프로세서, 기억장치, 입출력 장치 등을 효율적으로 관리한다.  
이는 전공자 입장에서 운영체제를 바라보는 핵심 기능이다. **운영체제 = 자원관리자**.

### 2. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공

#### 사용자와 상호작용

여러 사용자들이 동시에 여러 프로그램을 사용할 때, 각각 독자적 컴퓨터에서 수행하고 있다는 환상을 제공한다.

#### 하드웨어와 상호작용

하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행한다.

### 자원은 무엇인가?

프로세서(CPU), 기억장치(메모리), 입출력 장치 등을 자원이라 부른다.

### 자원의 관리

#### 프로세서

CPU는 컴퓨터 안에서 **가장 빠른 자원**이며, 최근에는 CPU가 멀티 코어, 멀티 프로세서 등 여러 개 달리지만 원칙적으로 하나이다.  
따라서 여러 프로그램이 동시에 실행되려면 아주 짧은 시간에 CPU를 번갈아가며 쓴다.  
이러한 CPU 할당 방식은 여러 프로그램들이 마치 각 프로그램 혼자 사용되고 있는 것 같이 느껴진다.

#### 기억장치

메모리는 정해진 공간에 여러 프로그램을 동시에 실행하기 위해, 메모리를 쪼개서 그 위에 프로그램을 올린다.

# Introduction to Operating Systems

## 운영체제란 무엇인가?

### 협의의 운영체제

#### 커널

운영체제의 핵심 부분으로, 부팅이 일어난 이후로 항상 메모리에 상주하는 부분을 말한다.  
**전공자 입장에서 운영체제는 보통 커널**만을 얘기함.

### 광의의 운영체제

#### 커널 + 각종 주변 시스템 유틸리티

하드웨어 위에 운영체제를 설치하게 되면 최소한의 필요한 유틸리티를 커널과 함께 설치한다.  
예를 들어, 윈도우를 설치하면 커널 뿐만 아니라 파일을 복사하는 별도의 프로그램 등도 추가로 설치된다.  
이 프로그램들은 커널에 포함되지는 않는 독립적 프로그램들이지만 운영체제의 범주에는 들어간다.

## 운영체제의 목적

### 1. 컴퓨터 시스템의 자원을 효율적으로 관리

#### 하드웨어 자원(프로세서, 기억장치, 입출력 장치 등)을 효율적으로 관리

관리 방향으로, 우선 주어진 자원으로 최대한의 성능을 내도록 유도하는 **효율성**을 추구한다.  
한편 사용자, 그리고 프로그램 간의 **형평성** 있는 자원 분배도 어느정도 고려해야 한다.

#### 소프트웨어 자원(프로세스, 파일, 메시지 등)을 관리

#### 사용자 및 운영체제 자신을 보호 계정을 만들어서 동시에 접속 가능

따라서 각 사용자의 파일, 메모리 접근 등의 보안 기능이나 사용자 간의 형평성 있는 자원 관리도 필요하다.  
그 예로, UNIX, NT server.

### 2. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공

#### 사용자와 상호작용

여러 사용자들이 동시에 여러 프로그램을 사용할 때, 각각 독자적 컴퓨터에서 수행하고 있다는 환상을 제공한다.

#### 하드웨어와 상호작용

하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행한다.

## 운영 체제의 분류

### 동시 작업 가능 여부

#### 단일 작업(Single tasking)

한 번에 하나의 작업만 처리한다. 이런 운영체제는 설계가 훨씬 간단하고 쉽다.  
예로 들어, MS-DOS, 엘리베이터 등의 특수 목적 기계.

#### 다중 작업(Multi tasking)

동시에 두 개 이상의 작업을 처리한다. **현대 대부분의 운영체계**.  
예로 들어, UNIX, MS Windows 등.

### 사용자의 수

여기서의 분류는 컴퓨터 한 대를 **여러 사용자**가 여러 계정을 만들고, 동시에 접속해서 쓸 수 있는지를 기준으로 삼는다.

#### 단일 사용자(Single user)

예) MS-DOS, MS Windows

#### 다중 사용자(Multi user)

예) UNIX, NT server

### 처리 방식

#### 일괄 처리(Batch processing)

작업 요청의 일정량을 모아서 한번에 처리. 이 때문에 작업이 완전 종료될 때까지 기다려야 함.  
현대 운영체제에선 찾기 힘들다. 초기의 Punch card 시스템이 대표적.

#### 시분할(Time sharing)

여러 작업을 수행할 때 **컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용**한다.  
일괄 처리 시스템에 비해 짧은 응답 시간. **오늘날 흔히 쓰는 컴퓨터의 방식**.  
사람에 특화되어, 사용자가 빠르다고 느끼게 해준다. 자원의 효율성과 상호작용성을 지님.

#### 실시간(Realtime OS)

정해진 시간 안에 특정 일이 반드시 종료됨이 보장되어야 하는 시스템을 위한 운영체제. 따라서 데드라인의 존재로 매우 정교하다.  
최근에는 실시간 시스템의 개념이 확장되어 경성/연성 실시간 시스템으로 나눌 수 있다.  

- Hard realtime system(경성 실시간 시스템) : 원자로/공장 제어, 미사일 제어, 반도치 장비 등.
- Soft realtime system(연성 실시간 시스템) : 동영상 재생 프로그램.

## 몇 가지 용어

### Multitasking, Multiprogramming, Time sharing, Multiprocessing

위 용어들은 모두 컴퓨터에서 여러 작업을 동시에 수행하는 것을 의미한다.

- Multitasking : 하나의 프로그램이 끝나기 전에 다른 프로그램을 실행 가능하다는 일반적인 용어.
- Multiprogramming : 여러 프로그램들이 메모리에 올라가 있음을 강조.
- Time sharing : CPU의 시간을 분할하여 쓴다는 의미를 강조.
- Multiprocessing : Multitasking과 유사.

### Multiprocessor

하드웨어적으로 **한 컴퓨터에 2개 이상의 CPU(Processor)가 장착**된 것을 의미한다.

## 운영체제의 예

### 유닉스(UNIX)

#### 코드의 대부분이 C언어로 작성

유닉스가 만들어진 시기의 운영체제는 어셈블리 언어, 즉 기계어에 가까운 언어로 만들어져 굉장히 코드가 복잡하고 어려웠다.  
그래서 유닉스를 만들기 위해 새로 만든 프로그래밍 언어가 바로 **C언어**. 따라서 유닉스는 대부분의 커널 코드가 C언어로 작성됨.  
C언어는 기계, 그리고 사람에 모두 가까운 언어다. 요즘도 시스템 소프트웨어를 만들때 C언어를 사용한다.

#### 높은 이식성

이식하기 어려운 운영체제란?  
한 컴퓨터에만 국한되게 만든 운영체제를 말한다. 이런 컴퓨터는 기계어 집합 자체가 다른 컴퓨터와 달라서 이식이 어려움.  
반면 유닉스는 대부분의 코드가 기계어와는 독립적인 C언어로 이루어져 있다. 그래서 다른 컴퓨터라도 C언어를 컴파일하면 유닉스를 쉽게 이식할 수 있다.

#### 최소한의 커널 구조와 높은 확장성

#### 소스 코드 공개

유닉스는 공개 소프트웨어 정신을 따른다. 이 영향으로 탄생한 결과가 바로 리눅스(Linux).  
오늘날 안드로이드의 운영체제 커널도 리눅스 커널을 쓰고 있다.

#### 프로그램 개발에 용이

#### 다양한 버전

* System V, FreeBSD, SunOS, Solaris
* Linux

### DOS(Disk Operating System)

MS사에서 1981년 IBM-PC를 위해 개발함. 개인용 컴퓨터를 위한 단일 사용자용 운영체제.  
한편 메모리 관리 능력의 한계로 쓸모 없어졌다(주기억장치 : 640KB).

### MS Windows

MS사의 다중 작업용 GUI 기반 운영체제. Plug and Play를 지원하고 네트워크 환경을 강화함.  
자사의 DOS용 응용 프로그램과 호환성 또한 제공했고, 풍부한 지원 소프트웨어를 지닌다.  
한편 요즘은 그렇지 않지만, 초창기 윈도우는 여러 프로그램 구동 시 죽어버려 재부팅이 필요했던 만큼 안정성이 낮았다.

### Handheld device를 위한 OS

PalmOS, Pocket PC(WinCE), Tiny OS

## 운영체제의 구조

### CPU 스케줄링

#### 누구한테 CPU를 줄까?

CPU는 아주 빠르므로 프로그램들에게 CPU를 줬다 뺐었다 반복하며 업무를 처리한다. 이러한 시간 관리의 이유는 컴퓨터의 천문학적 시간차 때문이다.  
디스크는 메모리에 비해 60만 배~100만 배 느리고, 메모리는 CPU에 비해 수백 배 느리다. 따라서 이 시간차를 완충하며 주어진 자원 특성을 최대한 활용하는 방식이 필요하다.  
바로 이 방식이 **CPU 스케줄링의 역할**이다.

이론적으로 볼 때는 CPU를 가장 짧게 이용할 프로그램부터 먼저 CPU를 주도록 배분하면, 평균적 성능은 좋아진다.  
그렇지만 최근에는 일반적으로 CPU를 주고 다시 가져오는 방식이 더 좋다는 관점에 입각해서 빠른 자원의 CPU 관리를 하는 쪽으로 발전되어 옴.

### 메모리 관리

#### 한정된 메모리를 어떻게 쪼개어 쓸까?

프로그램은 실행되면 메모리 위에 올라가는데, 프로그램이 너무 많아져 각각의 프로그램이 갖는 메모리 공간이 너무 작아지면 실행이 안된다.  
그리고 메모리가 지나치게 작게 할당된 프로그램은 CPU가 그 프로그램이 메모리에 없다고 판단해서, 다시 디스크에서 읽어온다.  
이러면 원할한 프로그램 실행이 안되기 때문에, 프로그램 하나가 최소한의 메모리는 받을 수 있도록 지원하는 것을 **워킹셋 모델**이라고 한다.

**워킹셋 모델**은 너무 많은 프로그램이 동시 실행되면, 일부 프로그램만 메모리에 할당해주고 나머지는 전부 디스크로 쫒아내서 원할한 실행을 유도한다.  
그리고 프로그램이 잘 실행이 됐으면 다시 디스크로 내려놓고, 쫓아냈던 프로그램을 메모리에 다시 올리는 효율적 방식의 관리.

그러면 여기서 중요한 이슈로, 디스크에서 새로운 것을 가져와 메모리에 올려놓으려면 누구를 쫓아낼 것인가?  
이는 CPU에서 다시 사용할 가능성 높은 프로그램은 놔두고 그렇지 않은건 쫓아내야 한다.  
재사용성을 판단하는 기준은 과거를 통해서 예측하는데, 자세한건 이후 메모리 관리에서 설명한다.

### 파일 관리

#### 디스크에 파일을 어떻게 보관할까?

디스크는 메모리와 달리, 접근하려면 **원판의 제일 안쪽과 바깥쪽을 내부의 헤드가 움직이면서 데이터를 읽어야 한다**.  
즉, 디스크의 특성에 맞게 파일 관리, 그리고 스케줄링이 필요하다.  
따라서 디스크는 들어온 요청들 중 헤드와 가까운 위치에 들어온 요청이 있다면 먼저 처리하는, 엘리베이터 스케줄링과 유사하다고 볼 수 있다.  
이렇게 **디스크 이동을 효율적으로 줄이는 방식을 통해 성능을 향상**시킨다.

### 입출력 관리

#### 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고 받을 수 있을까?

IO Device는 CPU나 메모리 등에 비해 훨씬 느리다. 그래서 입출력 장치는 보통 **인터럽트**에 기반해서 관리한다.  

**인터럽트**는 입출력 장치에서 CPU에 보고할 일이 생기면, 이미 빠르게 다른 일을 처리하고 있는 CPU에게 인터럽트를 거는 것.  
CPU가 인터럽트가 걸리면, CPU는 다음 작업을 하기 전에 입출력 장치의 요청을 먼저 처리해준다. 이런 방식으로 CPU가 최대한 방해받지 않도록 한다.

### 프로세스 관리

- 프로세스의 생성과 삭제
- 자원 할당 및 반환
- 프로세스 간 협력

### 그 외

- 보호 시스템
- 네트워킹
- 명령어 해석기(Command line interpreter)

!그림

## 운영체제 과목의 수강 태도

### OS 사용자 관점이 아니라 OS 개발자 관점에서 고려하는 자세

수업에서 다루는 대부분의 알고리즘은 OS 프로그램 자체의 내용이다.  
그리고 컴퓨터 하드웨어는 운영체제의 통제를 받고, 그 운영체제는 사람이 프로그래밍한다.  
따라서 본인이 직접 운영체제가 되었다고 생각해보고, 할 일이 무엇인지 생각해보자.