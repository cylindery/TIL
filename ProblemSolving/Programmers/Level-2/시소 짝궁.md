# 시소 짝꿍

> https://school.programmers.co.kr/learn/courses/30/lessons/152996

### 내 코드

```java
import java.util.*;

class Solution {
    Map<Double, Integer> map;

    public long solution(int[] weights) {
        long ans = 0;
        Arrays.sort(weights);
        map = new HashMap<>();

        for (double w : weights) {
            double a = w;
            double b = w * 2 / 3;
            double c = w / 2;
            double d = w * 3 / 4;

            if (map.containsKey(a)) ans += map.get(a);
            if (map.containsKey(b)) ans += map.get(b);
            if (map.containsKey(c)) ans += map.get(c);
            if (map.containsKey(d)) ans += map.get(d);

            map.put(a, map.getOrDefault(a, 0) + 1);
        }

        return ans;
    }
}
```

### 피드백

- Map을 이용해서 O(N)의 시간복잡도로 시소 짝꿍 쌍의 개수 찾기.
    - weights 길이가 10만이므로 N^2 복잡도는 시간 초과. 따라서 처음 생각한 것은 오름차순 정렬한 뒤, 현재 인덱스 뒤에서부터 끝까지 이진 탐색으로 찾으려고 했다.
        - 하지만 뒤에 쌍이 되는 값이 여러개, 최대 length-1의 길이만큼 반복될 수 있으므로 전부 카운팅하다보면 시간복잡도 증가 가능.
    - 그런데 생각해보면 한 값에 대해 시소 쌍을 이룰 수 있는 케이스는 크게 7가지 밖에 없다.
        - 여기에 오름차순 정렬하면 현재 인덱스 값 이전에 대해 같거나, 작은 값만 탐색하면 된다.
        - 따라서 Map에 현재 개수를 value에 할당하며 카운팅.

### 출처

- 