# 뒤에 있는 수 찾기

> https://school.programmers.co.kr/learn/courses/30/lessons/154539

### 내 코드

```java
import java.util.*;

class Solution {
    public int[] solution(int[] numbers) {
        int[] ans = new int[numbers.length];
        int n = ans.length;

        for (int i = 0; i < n - 1; i++) {
            int cur = numbers[i];
            boolean flag = false;
            for (int j = i + 1; j < n; j++) {
                if (cur < numbers[j]) {
                    ans[i] = numbers[j];
                    flag = true;
                    break;
                }
            }
            if (!flag) ans[i] = -1;
        }
        ans[n - 1] = -1;

        return ans;
    }
}
```

### 참고한 코드

```java
import java.util.*;

class Solution {
    public int[] solution(int[] numbers) {
        int[] ans = new int[numbers.length];
        Arrays.fill(ans, -1);

        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < numbers.length; i++) {
            while (!stack.isEmpty() && numbers[i] > numbers[stack.peek()]) {
                ans[stack.pop()] = numbers[i];
            }
            stack.push(i);
        }

        return ans;
    }
}
```

### 참고한 코드 2

```java
import java.util.*;

class Solution {
    public int[] solution(int[] numbers) {
        int[] ans = new int[numbers.length];
        Stack<Integer> stack = new Stack<>();

        for (int i = numbers.length - 1; i >= 0; i--) {
            int cur = numbers[i];
            while (!stack.isEmpty() && stack.peek() <= cur) {
                stack.pop();
            }
            if (stack.isEmpty()) {
                ans[i] = -1;
            } else {
                ans[i] = stack.peek();
            }
            stack.push(cur);
        }

        return ans;
    }
}

```

### 피드백

- 스택을 활용해 현재 인덱스 값과 이전 인덱스 값의 뒤에 있는 수를 갱신하기.
    - 처음 내 코드에선 테스트 20~23 시간 초과. 바깥쪽 루프는 최악의 경우 n-1, 안쪽도 n-1이 발생하여 O(N^2)이 발생한다.
        - 따라서 정답으로는 스택을 사용하며 인덱스 값을 집어넣는 것이다. 현재 값보다 작은 값을 지닌 인덱스들은 pop하며 현재 값으로 정답을 넣어주고 진행하다보면 새로운 값마다 이전의 값들을 갱신할 수
          있다.
        - 뒤에서 루프를 시작하는 경우, 현재보다 작은 숫자를 스택에서 제거하며, 스택의 크기를 줄이고 다음 큰 수를 빠르게 찾는 방법도 있다.

### 출처

- 