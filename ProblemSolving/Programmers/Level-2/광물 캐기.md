# 광물 캐기

> https://school.programmers.co.kr/learn/courses/30/lessons/172927

### 참고한 내 코드

```java
import java.util.*;

class Solution {
    public int solution(int[] picks, String[] minerals) {
        // picks 순서대로 넣기
        Queue<String> pq = new ArrayDeque<>();
        int pCnt = 0;
        for (int i = 0; i < 3; i++) {
            String pick;
            for (int j = 0; j < picks[i]; j++) {
                if (i == 0) pick = "diamond";
                else if (i == 1) pick = "iron";
                else pick = "stone";
                pq.add(pick);
                pCnt++;
            }
        }

        // minerals 5개 묶음으로 넣기. 전체 크기가 큰 순으로 poll
        Queue<Minerals> mq = new PriorityQueue<>((o1, o2) -> (o2.getTotal() - o1.getTotal()));
        for (int i = 0; i < pCnt; i++) {
            int idx = i * 5;
            if (idx >= minerals.length) break;

            Minerals mineralSet = new Minerals();
            int len = Math.min(5, minerals.length - idx);
            for (int j = idx; j < idx + len; j++) {
                if (minerals[j].equals("diamond")) mineralSet.diamondCnt++;
                else if (minerals[j].equals("iron")) mineralSet.ironCnt++;
                else mineralSet.stoneCnt++;
            }
            mq.add(mineralSet);
        }

        int ans = 0;
        while (!pq.isEmpty() && !mq.isEmpty()) {
            String pick = pq.poll();
            Minerals mineralSet = mq.poll();
            ans += mineralSet.total(pick);
        }

        return ans;
    }

    static class Minerals {
        int diamondCnt, ironCnt, stoneCnt;

        public int getTotal() {
            return diamondCnt * 25 + ironCnt * 5 + stoneCnt;
        }

        public int total(String pick) {
            switch (pick) {
                case "diamond":
                    return diamondCnt + ironCnt + stoneCnt;
                case "iron":
                    return diamondCnt * 5 + ironCnt + stoneCnt;
                case "stone":
                    return diamondCnt * 25 + ironCnt * 5 + stoneCnt;
                default:
                    return -1;
            }
        }
    }
}
```

### 피드백

- 주어진 곡괭이와 광물 조합에서 최소한의 피로도를 그리디 알고리즘으로 풀기.
    - 곡괭이의 차례는 임의로 선택할 수 있고, 광물 조합은 무조건 앞에서부터 5개씩, 또는 광물이 끝난다면 그 이하로 끊어서 캐야한다.
        - 핵심은 최소한의 피로도이므로 가장 피로도가 많이 드는 구간은 가장 효율이 좋은 곡괭이로 캐는 것이다.
        - 따라서 앞에서부터 5개씩 묶었을 때, 최악의 상황인 돌 곡괭이로 드는 피로도를 계산한 뒤, 가장 높은 피로도 구간을 다이아 곡괭이부터 되는대로 캐면 된다.
    - 한편 테스트 케이스 8에서 계속 실패가 났는데, 무조건 5개씩 묶어서 미네랄 셋을 묶어서 그렇다.
        - 예를 들어, [0,1,0] -> ["diamond", "iron", "iron", "iron", "iron", "diamond", "diamond", "iron", "iron", "iron"]
          경우가 있다.
        - 곡괭이는 1개 밖에 없어서, 앞에서부터인 0~4 돌만 캘 수 있는데, 우선순위 큐로 두 번째 셋이 나와버리니 오류.
        - 이 방법을 해결하기 위해선 우선순위 큐에 넣을 때 단순 5번씩 끊어서 모든 미네랄을 루프하는게 아니라, 곡괭이의 개수로 루프하면 된다.

### 출처

- https://lordofkangs.tistory.com/689
- https://stritegdc.tistory.com/406