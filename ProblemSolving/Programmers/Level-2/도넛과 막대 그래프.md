# 도넛과 막대 그래프

> https://school.programmers.co.kr/learn/courses/30/lessons/258711

### 참고한 내 코드 1

```java
import java.util.*;

class Solution {
    public int[] solution(int[][] edges) {
        int[] ans = new int[4];
        Map<Integer, Node> map = new HashMap<>();

        for (int[] cur : edges) {
            if (!map.containsKey(cur[0])) {
                map.put(cur[0], new Node(0, 0));
            }
            if (!map.containsKey(cur[1])) {
                map.put(cur[1], new Node(0, 0));
            }

            map.get(cur[0]).out += 1;
            map.get(cur[1]).in += 1;
        }

        for (int key : map.keySet()) {
            Node node = map.get(key);

            if (node.out >= 2 && node.in == 0) {
                ans[0] = key;
            } else if (node.out >= 2 && node.in == 2) {
                ans[3]++;
            } else if (node.out == 1 && node.in == 0) {
                ans[2]++;
            }
        }

        ans[1] = map.get(ans[0]).out - ans[2] - ans[3];

        return ans;
    }

    static class Node {
        int out, in;

        public Node(int out, int in) {
            this.out = out;
            this.in = in;
        }
    }
}
```

### 참고한 코드 2

```java
import java.util.*;

class Solution {
    public int[] solution(int[][] edges) {
        int[] ans = new int[4];

        int n = 1000001;
        int[] out = new int[n];
        int[] in = new int[n];

        for (int[] edge : edges) {
            out[edge[0]]++;
            in[edge[1]]++;
        }

        for (int i = 1; i < n; i++) {
            if (out[i] >= 2 && in[i] == 0) {
                ans[0] = i;
            } else if (out[i] == 0 && in[i] >= 1) {
                ans[2]++;
            } else if (out[i] == 2 && in[i] >= 2) {
                ans[3]++;
            }
        }
        ans[1] = out[ans[0]] - ans[2] - ans[3];

        return ans;
    }
}
```

### 피드백

- 주어진 그래프의 각 노드와 간선의 수를 응용하는 사고가 필요했던 문제.
    - 처음에는 단순히 새로 생성한 정점을 찾고, 나머지 정점들에 대해서 dfs를 활용해 각 그래프의 성격을 찾고 카운팅하려 했다.
        - 하지만 주어진 edges의 길이가 100만 이하, 그리고 정점의 갯수가 10만 이하이기 때문에 단순히 모든 정점을 탐색하는 dfs를 활용하다 보면, 시간복잡도가 초과하기 마련.
    - 따라서 다른 방법이 필요한데, 핵심은 각 그래프의 특징적인 정점을 찾는 것과 그 정점의 간선 성격이다.
        - 우선 생성한 정점의 경우, 나가는 간선은 최소 2개 이상이고 들어오는 간선은 유일하게 0이다.
        - 다음으로 막대 모양 그래프의 경우, 한 그래프에 한 정점은 무조건 나가는 간선이 0이다. 이러한 정점은 막대 모양 그래프에 딱 하나 있다.
        - 8자 모양 그래프의 경우, 반드시 가운데 정점에는 한 개의 나가는 간선 2개, 들어오는 간선 2개가 존재한다. 하지만 그 정점에 생성한 정점이 연결될 수 있기 때문에, 들어오는 간선 3개 이상
          가능.
        - 나머지 도넛 모양 그래프는 전체 그래프 수에서 막대와 8자를 빼주면 된다.
- 굉장히 시간이 오래걸린 문제였다. 처음엔 dfs를 구현하는 고민만 하다가 시간을 날렸다. 머리를 좀 더 유연하게, 그리고 문제를 수학적으로 접근해보자.

### 출처

- https://tech.kakao.com/posts/610