# 부대복귀

> https://school.programmers.co.kr/learn/courses/30/lessons/132266

### 내 코드

```java
import java.util.*;

class Solution {
    public int[] solution(int n, int[][] roads, int[] sources, int destination) {
        ArrayList<Integer>[] map = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            map[i] = new ArrayList<>();
        }
        for (int[] road : roads) {
            map[road[0]].add(road[1]);
            map[road[1]].add(road[0]);
        }

        Queue<Integer> q = new ArrayDeque<>();
        q.offer(destination);
        int[] vis = new int[n + 1];
        Arrays.fill(vis, -1);
        vis[destination] = 0;
        while (!q.isEmpty()) {
            int cur = q.poll();
            int size = map[cur].size();
            for (int i = 0; i < size; i++) {
                int next = map[cur].get(i);
                if (vis[next] >= 0) continue;
                q.offer(next);
                vis[next] = vis[cur] + 1;
            }
        }

        int[] ans = new int[sources.length];
        int idx = 0;
        for (int s : sources) {
            ans[idx] = vis[s];
            idx++;
        }

        return ans;
    }
}
```

### 피드백

- 그래프의 연결된 노드 중 destination 노드를 시작으로, 갈 수 있는 모든 노드를 최단거리로 계산하면 쉽게 풀리는 문제.
    - 모든 노드를 처음부터 -1로 초기화한 뒤, destination 부터 시작해 방문한 적 없는 노드면 현재 노드 +1 거리를 할당해줬다.
    - n이 10만에 이르므로 매번 노드마다 모든 노드를 루프해 탐색하기 보다, 각 노드의 연결된 사이즈에 맞게 노드를 루프하여 시간을 줄였다.

### 출처

- 