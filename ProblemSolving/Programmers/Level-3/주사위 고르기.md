# 주사위 고르기

> https://school.programmers.co.kr/learn/courses/30/lessons/258709

### 내 코드

```java
import java.util.*;

class Solution {
    static int n, win = 0;
    static int[] ans;
    static int[][] copyDice;
    static boolean[] vis;

    public int[] solution(int[][] dice) {
        n = dice.length;
        ans = new int[n / 2];
        copyDice = new int[n][6];
        for (int i = 0; i < n; i++) {
            copyDice[i] = dice[i].clone();
        }
        vis = new boolean[n];

        // 주사위 나누기
        divDice(0, 0, 0);

        // +1 인덱스 해서 리턴
        for (int i = 0; i < ans.length; i++) {
            ans[i] += 1;
        }

        return ans;
    }

    public void divDice(int idx, int cntA, int cntB) {
        if (cntA == n / 2 && cntB == n / 2) { // 주사위 나누기 성공
            // 나뉜 주사위에 따라 A 승률 계산
            int tmpWin = calcRate();
            if (win < tmpWin) {
                win = tmpWin;
                int[] tmpA = new int[n / 2];
                int idxA = 0;
                for (int i = 0; i < vis.length; i++) {
                    if (vis[i]) tmpA[idxA++] = i;
                }
                ans = tmpA.clone();
            }
            return;
        }
        if (cntA > n / 2 || cntB > n / 2 || idx == n) return; // 주사위 나누기 실패

        vis[idx] = true;
        divDice(idx + 1, cntA + 1, cntB);
        vis[idx] = false;
        divDice(idx + 1, cntA, cntB + 1);
    }

    public int calcRate() {
        int wins = 0;
        int[] a = new int[n / 2];
        int[] b = new int[n / 2];
        int aIdx = 0, bIdx = 0;

        for (int i = 0; i < n; i++) {
            if (vis[i]) a[aIdx++] = i;
            else b[bIdx++] = i;
        }

        int[] aSums = new int[(int) Math.pow(6, n / 2)];
        int[] bSums = new int[(int) Math.pow(6, n / 2)];

        genSums(a, 0, 0, 0, aSums);
        genSums(b, 0, 0, 0, bSums);

        Arrays.sort(bSums);

        for (int sumA : aSums) {
            int pos = Arrays.binarySearch(bSums, sumA);
            if (pos < 0) {
                pos = -pos - 1;
            }
            wins += pos;
        }

        return wins;
    }

    public void genSums(int[] dice, int idx, int sum, int sumIdx, int[] sums) {
        if (idx == dice.length) {
            sums[sumIdx] = sum;
            return;
        }

        for (int i = 0; i < 6; i++) {
            genSums(dice, idx + 1, sum + copyDice[dice[idx]][i], sumIdx * 6 + i, sums);
        }
    }
}
```

### 참고한 코드

```java
import java.util.*;

class Solution {
    static int n, win = 0;
    static int[] ans;
    static int[][] copyDice;
    static boolean[] vis;

    public int[] solution(int[][] dice) {
        n = dice.length;
        ans = new int[n / 2];
        copyDice = new int[n][6];
        for (int i = 0; i < n; i++) {
            copyDice[i] = dice[i].clone();
        }
        vis = new boolean[n];

        // 주사위 나누기
        divDice(0, 0, 0);

        // +1 인덱스 해서 리턴
        for (int i = 0; i < ans.length; i++) {
            ans[i] += 1;
        }

        return ans;
    }

    public void divDice(int idx, int cntA, int cntB) {
        if (cntA == n / 2 && cntB == n / 2) { // 주사위 나누기 성공
            // 나뉜 주사위에 따라 A 승률 계산
            int tmpWin = calcRate();
            if (win < tmpWin) {
                win = tmpWin;
                int[] tmpA = new int[n / 2];
                int idxA = 0;
                for (int i = 0; i < vis.length; i++) {
                    if (vis[i]) tmpA[idxA++] = i;
                }
                ans = tmpA.clone();
            }
            return;
        }
        if (cntA > n / 2 || cntB > n / 2 || idx == n) return; // 주사위 나누기 실패

        vis[idx] = true;
        divDice(idx + 1, cntA + 1, cntB);
        vis[idx] = false;
        divDice(idx + 1, cntA, cntB + 1);
    }

    public int calcRate() {
        int wins = 0;
        int[] a = new int[n / 2];
        int[] b = new int[n / 2];
        int aIdx = 0, bIdx = 0;

        for (int i = 0; i < n; i++) {
            if (vis[i]) a[aIdx++] = i;
            else b[bIdx++] = i;
        }

        int[] aSums = new int[(int) Math.pow(6, n / 2)];
        int[] bSums = new int[(int) Math.pow(6, n / 2)];

        genSums(a, 0, 0, 0, aSums);
        genSums(b, 0, 0, 0, bSums);

        Arrays.sort(bSums);

        for (int sumA : aSums) {
            int left = 0;
            int right = bSums.length - 1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (sumA > bSums[mid]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            wins += left;
        }

        return wins;
    }

    public void genSums(int[] dice, int idx, int sum, int sumIdx, int[] sums) {
        if (idx == dice.length) {
            sums[sumIdx] = sum;
            return;
        }

        for (int i = 0; i < 6; i++) {
            genSums(dice, idx + 1, sum + copyDice[dice[idx]][i], sumIdx * 6 + i, sums);
        }
    }
}
```

### 피드백

- 내 코드로 돌리면 테스트 8, 9, 18에서 실패가 난다. 이진탐색을 이용해 시간복잡도를 해결했더니, 일부 케이스에선 정답이 안 나오는데 왜일까?
    - Arrays.binarySearch() 부분을 직접 구현했더니 정답.
        - 왜 그런가 찾아봤더니, `Arrays.binarySearch()`가 중복된 값에 대해 임의의 인덱스를 반환한다고 한다. 가장 처음의 인덱스가 아니라.
        - 공식 문서를 찾아봐도, '지정된 값을 가진 여러 요소가 포함된 경우 어떤 요소가 발견될지 보장할 수 없습니다' 라고 쓰여있다.
        - 따라서 코딩 테스트에서 binarySearch() 메서드를 사용하는 건 위험한 것 같다. 그냥 직접 구현하는 게 낫겠다.

### 출처

- https://codingdog.tistory.com/entry/java-arrays-binarysearch-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B4%85%EC%8B%9C%EB%8B%A4
- https://tech.kakao.com/posts/610
- https://rachel0115.tistory.com/entry/Java-%EC%A0%95%EB%A0%AC%EB%90%9C-%EB%B0%B0%EC%97%B4%EC%97%90%EC%84%9C-%EC%82%BD%EC%9E%85-%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EC%B0%BE%EA%B8%B0-ArraysbinarySearch
- https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#binarySearch(int[],int)