# 연속 펄스 부분 수열의 합

> https://school.programmers.co.kr/learn/courses/30/lessons/161988

### 내 코드

```java
import java.util.*;

class Solution {
    static int n;

    public long solution(int[] sequence) {
        long answer = 0;
        n = sequence.length;

        int[] pulse1 = new int[n];
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) pulse1[i] = sequence[i];
            else pulse1[i] = sequence[i] * -1;
        }
        int[] pulse2 = new int[n];
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) pulse1[i] = sequence[i] * -1;
            else pulse1[i] = sequence[i];
        }

        long max1 = getMax(pulse1);
        long max2 = getMax(pulse2);
        answer = Math.max(max1, max2);

        return answer;
    }

    public long getMax(int[] pulse) {
        long max = 0L;
        long[] sum = new long[n];

        if (pulse[0] > 0) sum[0] = pulse[0];
        for (int i = 1; i < n; i++) {
            int cur = pulse[i];
            long tmp = pulse[i] + sum[i - 1];
            if (tmp > 0) {
                sum[i] = tmp;
            } else {
                sum[i] = 0;
            }
        }

        for (int i = 0; i < n; i++) max = Math.max(max, sum[i]);

        return max;
    }
}
```

### 참고한 내 코드

```java
import java.util.*;

class Solution {
    static int n;

    public long solution(int[] sequence) {
        long answer = 0;
        n = sequence.length;
        long[][] cache = new long[n + 1][2];

        for (int i = 1; i <= n; i++) {
            int cur = sequence[i - 1];

            if (i % 2 == 0) {
                cache[i][0] = cur;
                cache[i][1] = cur * -1;
            } else {
                cache[i][0] = cur * -1;
                cache[i][1] = cur;
            }

            if (cache[i][0] < cache[i - 1][0] + cache[i][0]) {
                cache[i][0] += cache[i - 1][0];
            }
            if (cache[i][1] < cache[i - 1][1] + cache[i][1]) {
                cache[i][1] += cache[i - 1][1];
            }

            answer = Math.max(answer, Math.max(cache[i][0], cache[i][1]));
        }

        return answer;
    }
}
```

### 피드백

- 첫 코드는 정확성 45.0 점. 이전까지의 연속된 최대합과 다음 인덱스의 값을 더했을 때, 양수이면 연속해서 더하고, 음수되면 초기화.
    - 분명 논리가 맞는데 계속 틀렸다고 나와서 다른 코드를 찾아봤는데, 핵심 논리 코드는 똑같았다.
    - 알고보니, 내 코드에서 pulse2를 초기화할 때, pulse1로 초기화했다. 이런 사소한 실수는 줄이도록 노력하자...
    - 부분 합, dp 알고리즘을 다시 한 번 점검하자.

### 출처

- 