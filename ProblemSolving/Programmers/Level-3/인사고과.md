# 인사고과

> https://school.programmers.co.kr/learn/courses/30/lessons/152995

### 내 코드 1

```java
import java.util.*;

class Solution {
    public int solution(int[][] scores) {
        int[] wan = scores[0].clone();
        Arrays.sort(scores, (o1, o2) -> {
            if (o1[0] == o2[0]) return o2[1] - o1[1];
            return o2[0] - o1[0];
        });
        int[] max = scores[0].clone();

        int maxA = max[0];
        int maxB = max[1];
        PriorityQueue<Score> pq = new PriorityQueue<>();
        pq.add(new Score(maxA, maxB, maxA + maxB));

        for (int i = 1; i < scores.length; i++) {
            int[] cur = scores[i];
            if (cur[1] < maxB) {
                continue;
            } else {
                maxB = cur[1];
                pq.add(new Score(cur[0], cur[1], cur[0] + cur[1]));
            }
        }

        int ans = 0;
        while (!pq.isEmpty()) {
            ans++;
            Score cur = pq.poll();
            if (cur.a == wan[0] && cur.b == wan[1]) {
                return ans;
            }
        }

        return -1;
    }

    static class Score implements Comparable<Score> {
        int a, b, sum;

        public Score(int a, int b, int sum) {
            this.a = a;
            this.b = b;
            this.sum = sum;
        }

        @Override
        public int compareTo(Score o) {
            return o.sum - this.sum;
        }
    }
}
```

### 참고한 코드

```java
import java.util.Arrays;

class Solution {
    public int solution(int[][] scores) {
        int answer;
        int size = scores.length;
        int n = scores[0][0];
        int m = scores[0][1];

        Arrays.sort(scores, (o1, o2) -> {
            if (o1[0] == o2[0]) {
                return o1[1] - o2[1];
            }
            return o2[0] - o1[0];
        });

        int maxScore = scores[0][1];

        for (int i = 1; i < size; i++) {
            if (scores[i][1] < maxScore) {
                if (scores[i][0] == n && scores[i][1] == m) return -1;
                scores[i][0] = -1;
                scores[i][1] = -1;
            } else {
                maxScore = scores[i][1];
            }
        }

        Arrays.sort(scores, (o1, o2) -> (o2[0] + o2[1]) - (o1[0] + o1[1]));

        answer = 1;

        for (int[] score : scores) {
            if (score[0] + score[1] > n + m) {
                answer++;
            } else {
                break;
            }
        }

        return answer;
    }
}
```

### 피드백

- 첫번째 코드 채점 결과 84점. 4, 11, 22, 24 실패. 아마 완호와 같은 점수가 먼저 나올 수 있어서 틀린 것 같다. + 처음 정렬할 때 오름차순.
    - 이유는 처음 scores를 정렬할 때, `if (o1[0] == o2[0]) return o2[1] - o1[1];`에서 a가 같으면 b는 반대로 오름차순 정렬해줘야 하기 때문이다.
    - 오름차순으로 정렬해야 가장 작은 b값에서 시작하며 더 큰 b값이 나오면 갱신하고, 갱신 이후에 작은 b값이 나왔을 땐 순위에서 제외할 수 있기 때문이다.
        - 예시 [[3,2], [3,1], [2,1], [1,2]]. 내림차순 정렬하면 [3,1]을 제외하게 됨.
    - 또한 pq를 이용해서 같은 sum값은 뭐가 먼저 나올지 모르기 때문에 완호가 같은 sum 값 중에서 가장 먼저 poll 한다는 보장이 없다.

### 출처

- https://chamggae.tistory.com/191