# n + 1 카드게임

> https://school.programmers.co.kr/learn/courses/30/lessons/258707

### 참고한 내 코드

```java
import java.util.*;

class Solution {
    public int solution(int coin, int[] cards) {
        int ans = 0;
        int n = cards.length;
        int idx = n / 3;
        int tar = n + 1;
        HashSet<Integer> set = new HashSet<>();
        HashSet<Integer> tmp = new HashSet<>();

        for (int i = 0; i < idx; i++) set.add(cards[i]);

        while (true) {
            ans++;
            if (idx == n) break;
            tmp.add(cards[idx]);
            tmp.add(cards[idx + 1]);

            boolean flag = false;
            for (int v : set) {
                if (set.contains(tar - v)) {
                    set.remove(v);
                    set.remove(tar - v);
                    flag = true;
                    break;
                }
            }

            if (!flag && coin > 0) {
                for (int t : tmp) {
                    if (set.contains(tar - t)) {
                        set.remove(tar - t);
                        tmp.remove(t);
                        coin--;
                        flag = true;
                        break;
                    }
                }
            }

            if (!flag && coin > 1) {
                for (int t : tmp) {
                    if (tmp.contains(tar - t)) {
                        tmp.remove(t);
                        tmp.remove(tar - t);
                        coin -= 2;
                        flag = true;
                        break;
                    }
                }
            }

            if (!flag) break;
            idx += 2;
        }

        return ans;
    }
}
```

### 피드백

- 일종의 dp 문제와 구현의 핵심인 문제.
    - 직접적으로 dp의 자료구조를 사용하진 않지만, 라운드 별 상태를 이용한다는 점에서 dp 문제라고 볼 수 있다.
    - 각 라운드 별로 고려해야 하는 요소는 크게 3가지. 현재 갖고 있는 카드, 이번 라운드에 새로 가져온 2개 카드, 남은 코인 수.
        - 최우선적으로 가장 라운드를 많이 진행하기 위해선, 최대한 코인을 쓰지 않으면서 기존의 카드로만 라운드를 넘기는 것이다.
        - 따라서 처음 받은 n / 3개의 카드를 set에 넣어둔 뒤, 매 라운드마다 set의 조합으로만 라운드를 넘길 수 있는지 탐색.
        - 여기서 넘길 수 없다면 남은 코인 수가 남아 있을 때, 새로 받은 카드 1장 + 기존 카드 1장 조합 or 기존 카드 2장 조합으로 라운드 넘길 수 있는지 탐색.
            - 참고로 매 라운드마다 tmp를 초기화시키지 않는 이유는, 이미 코인을 쓰지 않고 지나갔지만 라운드를 진행하다 보니 그 카드가 필요했을 수도 있으니 tmp에 누적으로 새 카드를 저장하는 것이고
              이 점이 매우 중요하다.
            - 여기서 나중에 해당 카드가 필요할 때 코인을 차감하며 다시 가져오는 아이디어를 떠올리는 것이 어려웠다.

### 출처

- https://velog.io/@hyeokkr/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4n1-%EC%B9%B4%EB%93%9C%EA%B2%8C%EC%9E%84-with-Java